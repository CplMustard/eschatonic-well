import { Clipboard } from "@capacitor/clipboard";

import { cardSorting } from "./sortingUtil";

import { getCortexesData, getCypherTypesData, getFactionsData, getModelTypesData, getModelsData, getWeaponsData, rulesets } from "../data";

const listOutputMessage = "Generated by [Eschatonic Well](https://github.com/CplMustard/eschatonic-well).";

export function copyForceToText(forceName, rulesetId, factionId, forceSize, forceModelsData, forceCyphersData, specialIssueModelsData, specialIssueCyphersData) {
    function printEntry(entry) {
        const cortexString = (entry.hardPointOptions && entry.hardPointOptions.length !== 0) 
            ? (entry.hardPointOptions.filter((hardPoint) => hardPoint.type === "cortex").map((cortex) => getCortexesData()[cortex.option].name).join(", "))
            : undefined;
        const weaponsString = (entry.hardPointOptions && entry.hardPointOptions.length !== 0) 
            ? (entry.hardPointOptions.filter((hardPoint) => hardPoint.type === "weapon").filter((weapon) => weapon.option !== "empty").map((weapon) => getWeaponsData()[weapon.option].name).join(", "))
            : undefined;
        return `${entry.name}${(entry.subtypes && entry.subtypes.includes("hero")) ? " (hero)" : ""}${cortexString ? `\n  - Cortex: ${cortexString}` : ""}${weaponsString ? `\n  - Weapons: ${weaponsString}` : ""}`;
    }

    let forceString = "";
    let newForceModelsData = forceModelsData;
    newForceModelsData = newForceModelsData.sort(cardSorting);
    
    //Extract free hero solos up to the free hero solo maximum
    const freeHeroSoloEntries = [];
    for(let i=0; i < forceSize.hero_solos; i++) {
        const index = newForceModelsData.findIndex(((forceModel) => forceModel.type === "solo" && (forceModel.subtypes && forceModel.subtypes.includes("hero"))));
        if (index !== -1) {
            freeHeroSoloEntries.push(newForceModelsData[index]);
            newForceModelsData = [...newForceModelsData.slice(0, index), ...newForceModelsData.slice(index + 1)];
        } else {
            break;
        }
    }
    //Extract champions
    const championEntries = newForceModelsData.filter(((forceModel) => (forceModel.subtypes && forceModel.subtypes.includes("champion"))));
    
    //Remove remaining hidden models
    newForceModelsData = newForceModelsData.filter(((forceModel) => !(getModelsData()[forceModel.modelId].hidden || getModelTypesData()[forceModel.type].hidden || (forceModel.subtypes && forceModel.subtypes.every((subtype) => getModelTypesData()[subtype].hidden)))));

    forceString += `\nForce: ${forceName}`;
    console.log(rulesetId);
    forceString += `\nRuleset: ${rulesetId ? rulesets[rulesetId].name : "Privateer Press"}`;
    forceString += `\nFaction: ${factionId ? getFactionsData()[factionId].name : "All"}`;
    forceString += `\nSize: ${forceSize.name}`;

    forceString += "\n\nUnits:";
    newForceModelsData.forEach((model) => {
        forceString += `\n- ${printEntry(model)}`;
    });

    if(freeHeroSoloEntries.length !== 0) {
        forceString += "\n\nExtra hero solos:";
        freeHeroSoloEntries.forEach((model) => {
            forceString += `\n- ${printEntry(model)}`;
        });
    }

    if(championEntries.length !== 0) {
        forceString += "\n\nBonus champions:";
        championEntries.forEach((model) => {
            forceString += `\n- ${printEntry(model)}`;
        });
    }
    
    if(forceCyphersData.length !== 0) {
        forceCyphersData = forceCyphersData.sort(cardSorting);

        forceString += "\n\nRack:";
        const forceGroups = forceCyphersData.reduce((memo, current) => {
            memo[current["type"]] = [...memo[current["type"]] || [], current];
            return memo;
        }, {});
        Object.entries(forceGroups).sort().forEach(([key, value]) => {
            forceString += `\n- ${getCypherTypesData()[key].name} (${value.length})`;
            value.forEach((cypher) => {
                forceString += `\n  - ${printEntry(cypher)}`;
            });
        });
    }

    if((specialIssueModelsData && specialIssueModelsData.length !== 0) || (specialIssueCyphersData && specialIssueCyphersData.length !== 0)) {
        forceString += "\n\nSpecial Issue:";

        specialIssueModelsData = specialIssueModelsData.sort(cardSorting);
        specialIssueCyphersData = specialIssueCyphersData.sort(cardSorting);

        if(specialIssueModelsData.length !== 0) {
            const forceGroups = specialIssueModelsData.reduce((memo, current) => {
                memo[current["type"]] = [...memo[current["type"]] || [], current];
                return memo;
            }, {});
            Object.entries(forceGroups).sort().forEach(([key, value]) => {
                forceString += `\n- ${getModelTypesData()[key].name}`;
                value.forEach((model) => {
                    forceString += `\n  - ${printEntry(model)}`;
                });
            });
        }

        if(specialIssueCyphersData.length !== 0) {
            const forceGroups = specialIssueCyphersData.reduce((memo, current) => {
                memo[current["type"]] = [...memo[current["type"]] || [], current];
                return memo;
            }, {});
            Object.entries(forceGroups).sort().forEach(([key, value]) => {
                forceString += `\n- ${getCypherTypesData()[key].name}`;
                value.forEach((cypher) => {
                    forceString += `\n  - ${printEntry(cypher)}`;
                });
            });
        }
    }

    forceString += `\n\n${listOutputMessage}`;

    const writeToClipboard = async (string) => {
        await Clipboard.write({
            string: string
        });
    };

    console.log(forceString);
    writeToClipboard(forceString);
}