import { Clipboard } from '@capacitor/clipboard';

import { cortexesData, cypherTypesData, factionsData, modelTypesData, modelsData, weaponsData } from '../data';

const listOutputMessage = "Generated by [Eschatonic Well](https://github.com/CplMustard/eschatonic-well)."

export function copyForceToText(forceName, factionId, forceSize, forceModelsData, forceCyphersData) {
    function printEntry(entry) {
        const cortexString = (entry.hardPointOptions && entry.hardPointOptions.length !== 0) 
            ? (entry.hardPointOptions.filter((hardPoint) => hardPoint.type === "cortex").map((cortex) => cortexesData[cortex.option].name).join(", "))
            : undefined;
        const weaponsString = (entry.hardPointOptions && entry.hardPointOptions.length !== 0) 
            ? (entry.hardPointOptions.filter((hardPoint) => hardPoint.type === "weapon").filter((weapon) => weapon.option !== "empty").map((weapon) => weaponsData[weapon.option].name).join(", "))
            : undefined;
        return `${entry.name}${(entry.subtypes && entry.subtypes.includes("hero")) ? " (hero)" : ""}${cortexString ? `\n  - Cortex: ${cortexString}` : ""}${weaponsString ? `\n  - Weapons: ${weaponsString}` : ""}`;
    }

    let forceString = "";
    let newForceModelsData = forceModelsData;
    //Extract free hero solos up to the free hero solo maximum
    const freeHeroSoloEntries = []
    for(let i=0; i < forceSize.hero_solos; i++) {
        const index = newForceModelsData.findIndex(((forceModel) => forceModel.type === "solo" && (forceModel.subtypes && forceModel.subtypes.includes("hero"))));
        if (index !== -1) {
            freeHeroSoloEntries.push(newForceModelsData[index]);
            newForceModelsData = [...newForceModelsData.slice(0, index), ...newForceModelsData.slice(index + 1)]
        } else {
            break;
        }
    }
    //Extract champions
    const championEntries = newForceModelsData.filter(((forceModel) => (forceModel.subtypes && forceModel.subtypes.includes("champion"))));
    
    //Remove remaining hidden models
    newForceModelsData = newForceModelsData.filter(((forceModel) => !(modelsData[forceModel.modelId].hidden || modelTypesData[forceModel.type].hidden || (forceModel.subtypes && forceModel.subtypes.every((subtype) => modelTypesData[subtype].hidden)))));

    forceString += `\nForce: ${forceName}`;
    forceString += `\nFaction: ${factionId ? factionsData[factionId].name : "All"}`;
    forceString += `\nSize: ${forceSize.name}`;

    forceString += `\n\nUnits:`;
    newForceModelsData.forEach((model) => {
        forceString += `\n- ${printEntry(model)}`;
    });

    if(freeHeroSoloEntries.length !== 0) {
        forceString += `\n\nExtra hero solos:`;
        freeHeroSoloEntries.forEach((model) => {
            forceString += `\n- ${printEntry(model)}`;
        });
    }

    if(championEntries.length !== 0) {
        forceString += `\n\nBonus champions:`;
        championEntries.forEach((model) => {
            forceString += `\n- ${printEntry(model)}`;
        });
    }
    
    if(forceCyphersData.length !== 0) {
        forceString += `\n\nRack:`;
        const forceGroups = forceCyphersData.reduce((memo, current) => {
            memo[current["type"]] = [...memo[current["type"]] || [], current];
            return memo;
        }, {});
        Object.entries(forceGroups).sort().forEach(([key, value]) => {
            forceString += `\n- ${cypherTypesData[key].name} (${value.length})`;
            value.forEach((cypher) => {
                forceString += `\n  - ${printEntry(cypher)}`;
            });
        })
    }

    forceString += `\n\n${listOutputMessage}`;

    const writeToClipboard = async (string) => {
        await Clipboard.write({
            string: string
        });
    };

    console.log(forceString)
    writeToClipboard(forceString);
}